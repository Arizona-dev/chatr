import e from"body-parser";import t from"compression";import s from"cors";import r from"express";import{createServer as a}from"http";import o from"morgan-body";import n from"passport";import{Server as i}from"socket.io";import d from"winston";import"winston-mongodb";import c from"mongoose";import l from"passport-google-oauth20";import{ExtractJwt as u,Strategy as m}from"passport-jwt";import p from"bcryptjs";import{StatusCodes as h}from"http-status-codes";import w,{DataTypes as g,Model as y,Op as I,ValidationError as f}from"sequelize";import v from"jsonwebtoken";import{v4 as E}from"uuid";import O from"sib-api-v3-sdk";var N={jwtSecret:process.env.JWT_SECRET,google:{clientId:process.env.GOOGLE_CLIENT_ID,clientSecret:process.env.GOOGLE_CLIENT_SECRET,callbackUrl:process.env.GOOGLE_CALLBACK_URL},frontBaseUrl:process.env.FRONT_BASE_URL||"http://localhost:8001",backBaseUrl:process.env.BACK_BASE_URL||"http://localhost:9000",mongodb:{dbname:process.env.MONGODB_DBNAME,host:process.env.MONGODB_HOST,port:process.env.MONGODB_PORT,login:process.env.MONGODB_LOGIN,password:process.env.MONGODB_PASSWORD,uri:process.env.MONGODB_URI},expressPort:process.env.PORT||9e3,env:process.env.NODE_ENV||"development",mailerKey:process.env.MAILER_KEY};c.set("strictQuery",!1),c.connect(N.mongodb.uri||"mongodb://localhost:27017/notes-project"),c.connection.on("connected",(()=>{console.log("Mongoose default connection open")})),c.connection.on("error",(e=>{console.log(`Mongoose default connection error: ${e}`)})),c.connection.on("disconnected",(()=>{console.log("Mongoose default connection disconnected")})),process.on("SIGINT",(()=>{c.connection.close((()=>{console.log("Mongoose default connection disconnected through app termination"),process.exit(0)}))}));const{transports:S}=d,R=d.createLogger({level:"info",format:d.format.json(),defaultMeta:{service:"user-service"},transports:[new S.MongoDB({db:c.connection,collection:"logs"})]});"production"!==process.env.NODE_ENV&&R.add(new d.transports.Console({format:d.format.simple()}));const U=new w(process.env.POSTGRES_DATABASE_URL,{newUrlParser:!0});U.authenticate().then((()=>{console.log("Postgres (with sequelize) default connection open.")})).catch((e=>{console.error(`Unable to connect to the database >> ${process.env.POSTGRES_DATABASE_URL}:`,e)}));class b extends y{}b.init({id:{type:g.UUID,defaultValue:g.UUIDV4,primaryKey:!0},text:{type:g.STRING,allowNull:!1},edited:{type:g.BOOLEAN,defaultValue:!1},deleted:{type:g.BOOLEAN,defaultValue:!1}},{sequelize:U,modelName:"message"});class T extends Error{constructor(e,t,s=!0,r=""){super(t),this.statusCode=e,this.isOperational=s,r?this.stack=r:Error.captureStackTrace(this,this.constructor)}}const D=Object.freeze({ROLE_ADMIN:"ROLE_ADMIN",ROLE_USER:"ROLE_USER"}),A=Object.freeze({PENDING:"PENDING",ACTIVE:"ACTIVE",BLOCKED:"BLOCKED",EXISTS:"EXISTS",UNKNOWN_USER:"UNKNOWN_USER",ADDED:"ADDED",ERROR_SAME_USER:"ERROR_SAME_USER"}),k=Object.freeze({CONFIRM_EMAIL:"CONFIRM_EMAIL",RESET_PASSWORD:"RESET_PASSWORD"});class _ extends y{}_.init({id:{type:g.UUID,defaultValue:g.UUIDV4,primaryKey:!0},status:{type:g.STRING,validate:{isIn:{args:[Object.values(A)],msg:`Status must be one of: ${Object.values(A)}`}},allowNull:!1}},{sequelize:U,modelName:"friend"}),_.addHook("beforeCreate",((e,t)=>_.findOne({where:{[I.or]:[{senderId:e.senderId,receiverId:e.receiverId},{senderId:e.receiverId,receiverId:e.senderId}]}}).then((e=>{if(e)throw new T(h.UNPROCESSABLE_ENTITY,"friend already exists")}))));class M extends y{}M.init({id:{type:g.UUID,defaultValue:g.UUIDV4,primaryKey:!0},email:{type:g.STRING,allowNull:!1,unique:!0,validate:{isEmail:!0}},password:{type:g.STRING,allowNull:!0,validate:{len:[8,100]}},googleId:{type:g.STRING,allowNull:!0,unique:!0},role:{type:g.STRING,allowNull:!1,defaultValue:D.ROLE_USER},username:{type:g.STRING,allowNull:!1,unique:!0,defaultValue:""},avatar:{type:g.STRING,allowNull:!0,defaultValue:`https://avatars.dicebear.com/api/male/${100*Math.random()}.svg`},active:{type:g.BOOLEAN,allowNull:!1,defaultValue:!1}},{sequelize:U,modelName:"user"}),M.addHook("beforeCreate",(async e=>{e.password&&(e.password=await p.hash(e.password,await p.genSalt()))})),M.addHook("beforeUpdate",(async(e,{fields:t})=>{t.includes("password")&&(e.password=await p.hash(e.password,await p.genSalt()))}));class j extends y{}j.init({id:{type:g.UUID,defaultValue:g.UUIDV4,primaryKey:!0},title:{type:g.STRING}},{sequelize:U,modelName:"interest"});class L extends y{}L.init({id:{type:g.UUID,defaultValue:g.UUIDV4,primaryKey:!0},token:{type:g.STRING,allowNull:!1},type:{type:g.STRING,allowNull:!1,validate:{isIn:{args:[Object.values(k)],msg:`type must be one of: ${Object.values(k)}`}}}},{sequelize:U,modelName:"token"}),b.belongsTo(M,{as:"sender",foreignKey:"senderId"}),b.belongsTo(M,{as:"receiver",foreignKey:"receiverId"}),_.belongsTo(M,{as:"sender",foreignKey:"senderId"}),_.belongsTo(M,{as:"receiver",foreignKey:"receiverId"}),M.hasMany(b,{as:"invitations",foreignKey:"receiverId"}),M.belongsToMany(j,{through:"UserInterest"}),j.belongsToMany(M,{through:"UserInterest"}),M.hasMany(L),L.belongsTo(M);const B=async e=>{const{email:t,username:s,password:r,interests:a}=e;if(!a?.length)throw new T(h.UNPROCESSABLE_ENTITY,"At least one interest is required");const o=await M.create({email:t,username:s,password:r}),n=await j.findAll({where:{id:{[I.in]:a.map((e=>e.id))}}});return await o.addInterests(n),M.findByPk(o.id,{include:[{model:j,as:"interests"}]})},G=async e=>v.sign({id:e.id},N.jwtSecret,{expiresIn:"1y"}),P=async(e,t)=>{try{const s=await M.findByPk(e.id,{include:[{model:j,as:"interests"}]});if(!s)return t(null,!1);t(null,s)}catch(e){t(e,!1)}},C=async(e,t,s,r)=>{try{const{id:e,emails:t}=s;let a=await M.findOne({where:{googleId:s.id}});a||(a=await B({googleId:e,email:t[0].value}),M.update({googleId:e},{where:{id:a.id},returning:!0}));r(null,{user:a,token:await G(a)})}catch(e){r(e,!1)}},x=e=>b.create(e),V=new Set,$=new Map;class K{constructor(e,t){this.socket=t,this.io=e,this.login(t.handshake.query.userId),this.io.sockets.emit("users.count",$.size),t.on("getMessages",(()=>this.getMessages())),t.on("message",(e=>this.handleMessage(e))),t.on("deleteUser",(e=>this.deleteUser(e))),t.on("connect_error",(e=>{console.log(`connect_error due to ${e.message}`)})),t.on("isTyping",(e=>{this.sendIsTyping(e)})),t.on("disconnect",(()=>{$.delete(this.socket.handshake.query.userId),e.sockets.emit("users.count",$.size)}))}login(e){$.set(e,this.socket)}async sendMessage(e){$.has(e.receiver.id)&&(this.io.sockets.to($.get(e.receiver.id).id).emit("message",e),this.io.sockets.to($.get(e.sender.id).id).emit("message",e)),await x({text:e.text,senderId:e.sender.id,receiverId:e.receiver.id})}async sendIsTyping(e){$.has(e.receiver.id)&&this.io.sockets.to($.get(e.receiver.id).id).emit("isTyping",{id:E(),...e})}getMessages(){V.forEach((e=>this.sendMessage(e)))}handleMessage(e){const t={id:E(),text:e.text,receiver:{...e.receiver},sender:{...e.sender},createdAt:Date.now()};V.add(t),this.sendMessage(t),V.delete(t)}deleteMessage(e){this.io.sockets.emit("deleteMessage",e)}deleteUser(e){$.delete(e)}}const q=e=>e.errors.reduce(((e,t)=>(e[t.path]=t.message,e)),{});O.ApiClient.instance.authentications["api-key"].apiKey=N.mailerKey;const z=r.Router();z.post("/register",(async(e,t,s)=>{try{const s=await B(e.body),r=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);await L.create({userId:s.id,token:r,type:k.CONFIRM_EMAIL}),await(async(e,t)=>{const s=new O.TransactionalEmailsApi,r={to:[{email:e}],templateId:2,params:{link:`${N.backBaseUrl}/api/v1/auth/validate?token=${t}`}};return s.sendTransacEmail(r)})(e.body.email,r),t.json({id:s.id})}catch(e){s(e)}})),z.post("/login",(async(e,t,s)=>{try{const{email:s,password:r}=e.body,a=await(async(e,t)=>{const s=await M.findOne({where:{email:e},include:[{model:j,as:"interests"}]});if(!s)throw new T(h.UNAUTHORIZED,"Incorrect credentials");if(!s.active)throw new T(h.UNAUTHORIZED,"User is not validated");if(s?.googleId)return!1;if(!await p.compare(t,s?.password))throw new T(h.UNAUTHORIZED,"Incorrect credentials");return s})(s,r),o=await G(a);t.send({user:a,token:o})}catch(e){s(e)}})),z.get("/validate",(async(e,t,s)=>{try{const{token:s}=e.query,r=await L.findOne({where:{token:s,type:k.CONFIRM_EMAIL},include:[{model:M,as:"user"}]});await r.destroy(),await M.update({active:!0},{where:{email:r?.user?.email},returning:!0,individualHooks:!0}),t.redirect(301,N.frontBaseUrl)}catch(e){s(e)}})),z.post("/reset-password",(async(e,t,s)=>{try{const{email:s}=e.body,r=await M.findOne({where:{email:s}});if(!r)throw new T(h.NOT_FOUND,"Invalid email");const a=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);await L.create({userId:r.id,token:a,type:k.RESET_PASSWORD}),await(async(e,t)=>{const s=new O.TransactionalEmailsApi,r={to:[{email:e}],templateId:3,params:{link:`${N.frontBaseUrl}/reset-password?token=${t}`}};return s.sendTransacEmail(r)})(s,a),t.json({id:r.id})}catch(e){s(e)}}));function H(e=D.ROLE_USER){return async(e,t,s)=>new Promise(((r,a)=>{n.authenticate("jwt",{session:!1},((e,t,s,r)=>async(r,a,o)=>{if(r||o||!a)return s(new T(h.UNAUTHORIZED,"unauthorized"));e.user=a,t()})(e,r,a))(e,t,s)})).then((()=>s())).catch((e=>{s(e)}))}const F=r.Router();F.post("/reset-password",(async(e,t,s)=>{try{const{token:s,password:r}=e.body,a=await L.findOne({where:{token:s,type:k.RESET_PASSWORD},include:[{model:M,as:"user"}]});if(!a)throw new T(h.UNAUTHORIZED,"Invalid token");await a.destroy(),await M.update({password:r},{where:{email:a?.user?.email},returning:!0,individualHooks:!0}),t.json({message:"Password has been changed"})}catch(e){s(e)}})),F.get("/token",H(),(async(e,t,s)=>{try{t.json(e.user)}catch(e){s(e)}})),F.put("/profile",H(),(async(e,t,s)=>{try{const{username:s,interests:r}=e.body,a=await M.findOne({where:{id:e.user.id},include:[{model:j,as:"interests"}]}).then((async e=>{if(!e)throw new T(h.NOT_FOUND,"User not found");e.username=s;const t=await j.findAll({where:{id:{[I.in]:r.map((e=>e.id))}}});return await e.setInterests(t),e.save()})).then((e=>M.findByPk(e.id,{include:[{model:j,as:"interests"}]})));t.json(a)}catch(e){s(e)}})),F.put("/password",H(),(async(e,t,s)=>{try{const{oldPassword:s,newPassword:r}=e.body,a=await M.findOne({where:{id:e.user.id}});if(!a)throw new T(h.NOT_FOUND,"User not found");if(!await p.compare(s,a?.password))throw new T(h.UNAUTHORIZED,"Invalid old password");const o=await M.update({password:r},{where:{id:e.user.id},returning:!0,individualHooks:!0});t.json(o)}catch(e){s(e)}}));const W=r.Router();W.post("/",H(),(async(e,t,s)=>{const{receiverId:r}=e.body,{id:a}=e.user;await _.findOne({where:{[I.or]:[{senderId:a,receiverId:r},{senderId:r,receiverId:a}]}})||s(new T(h.UNAUTHORIZED,"You are not friends with this user")),s()}),(async(e,t,s)=>{try{const{text:s,receiverId:r}=e.body,a=await x({text:s,senderId:e.user.id,receiverId:r});t.json(a)}catch(e){s(e)}})),W.put("/:messageId",H(),(async(e,t,s)=>{const{id:r}=e.user,{messageId:a}=e.params;(await b.findByPk(a)).senderId!==r&&s(new T(h.UNAUTHORIZED,"Cant edit a message that is not yours")),s()}),(async(e,t,s)=>{try{const{messageId:s}=e.params,{body:r}=e,a=await((e,t)=>b.update(t,{where:{id:e},returning:!0}))(s,r);t.json(a)}catch(e){s(e)}})),W.get("/:senderId/:receiverId",H(),(async(e,t,s)=>{try{const{senderId:s,receiverId:r}=e.params,a=await((e,t)=>b.findAll({where:{[I.or]:[{senderId:e,receiverId:t},{senderId:t,receiverId:e}]},include:[{model:M,as:"sender",attributes:["email"]},{model:M,as:"receiver",attributes:["email"]}],order:[["createdAt","ASC"]]}))(s,r);t.json(a)}catch(e){s(e)}}));const Z=r.Router();Z.get("/:userId",H(),(async(e,t,s)=>{try{const{userId:s}=e.params,r=await(async(e,t=[A.ACTIVE,A.PENDING])=>_.findAll({where:{[I.or]:[{senderId:e},{receiverId:e}],status:{[I.or]:t}},include:[{model:M,as:"sender",attributes:["id","email","username","avatar"]},{model:M,as:"receiver",attributes:["id","email","username","avatar"]}]}))(s);t.json(r||[])}catch(e){s(e)}})),Z.post("/add",H(),(async(e,t,s)=>{try{const{receiverNameOrEmail:s}=e.body,r=await(({senderId:e,receiverId:t})=>""===t||void 0===t?"null":M.findOne({where:{[I.or]:[{username:t},{email:t}]}}).then((t=>t?t.id===e?{status:"ERROR_SAME_USER"}:_.findOne({where:{[I.or]:[{senderId:e,receiverId:t.id},{senderId:t.id,receiverId:e}]}}).then((s=>{if(s)switch(s.status){case A.ACTIVE:return{status:A.EXISTS};case A.PENDING:return{status:A.PENDING}}return _.create({senderId:e,receiverId:t.id,status:A.PENDING}).then((()=>({status:A.ADDED})))})):{status:A.UNKNOWN_USER})).catch((e=>{console.log(e)})))({senderId:e.user.id,receiverId:s});t.json(r)}catch(e){s(e)}})),Z.put("/:friendId",H(),(async(e,t,s)=>{try{const{friendId:s}=e.params,r=await(e=>_.update({status:A.ACTIVE},{where:{id:e},returning:!0}).then((e=>e[1][0])))(s);t.json(r)}catch(e){s(e)}})),Z.delete("/:friendId",H(),(async(e,t,s)=>{try{const{friendId:s}=e.params,r=await _.destroy({where:{id:s}});t.json(r)}catch(e){s(e)}})),Z.get("/:friendId/chat",H(),(async(e,t,s)=>{try{const{friendId:s}=e.params,o=await(r=s,a=e.user.id,b.findAll({where:{[I.or]:[{senderId:r,receiverId:a},{senderId:a,receiverId:r}]},include:[{model:M,as:"sender",attributes:["id","email","username","avatar"]},{model:M,as:"receiver",attributes:["id","email","username","avatar"]}]}).then((async e=>({friend:await M.findOne({where:{id:r},attributes:["id","email","username","avatar"]}),messages:e}))).catch((e=>{console.log(e)})));t.json(o||{})}catch(e){s(e)}var r,a}));const J=r.Router();J.get("/",(async(e,t,s)=>{try{const e=await j.findAll({});t.json(e)}catch(e){s(e)}}));const Y=new c.Schema({level:{type:String,required:!0},message:{type:String,required:!0},timestamp:{type:Date,default:Date.now},meta:{type:Object,required:!1}},{timestamps:!0});Y.index({message:"text"});const X=c.model("Log",Y),Q=r.Router();Q.post("/",H(),(async(e,t,s)=>{try{const{level:s,message:r,meta:a}=e.body;switch(s){case"error":R.error(r,{metadata:a});break;case"warn":R.warn(r,{metadata:a});break;case"info":R.info(r,{metadata:a});break;default:throw new Error("Level is not valid")}t.json({message:r,meta:a})}catch(e){s(e)}})),Q.post("/search",H("ROLE_ADMIN"),(async(e,t,s)=>{try{const{startDate:s,endDate:r,page:a,limit:o,textSearch:n,severity:i,application:d}=e.body,c={...n&&{$text:{$search:n}},...i&&{level:i},...d&&{"meta.service":d},...s&&r&&{timestamp:{$gte:new Date(s),$lte:new Date(r)}}},l=await X.find(c).skip(a*o).limit(o).sort({timestamp:-1}),u=await X.countDocuments(c);t.json({logs:l,total:u})}catch(e){s(e)}}));const ee=r.Router();[{path:"auth",routes:z},{path:"users",routes:F},{path:"messages",routes:W},{path:"friends",routes:Z},{path:"interests",routes:J},{path:"logs",routes:Q}].forEach((e=>{ee.use(`/${e.path}`,e.routes)}));const te=r();te.use(s({origin:"*"})),te.use(e.json()),o(te,{logResponseBody:!0}),te.use(r.json()),function(e){e.use(n.initialize()),n.serializeUser(((e,t)=>{t(null,e)})),n.deserializeUser(((e,t)=>{t(null,e)}));const t={jwtFromRequest:u.fromAuthHeaderAsBearerToken(),secretOrKey:N.jwtSecret};n.use(new m(t,P)),n.use(new l.Strategy({clientID:N.google.clientId,clientSecret:N.google.clientSecret,callbackURL:N.google.callbackUrl},C))}(te),te.use(t({level:9})),te.use("/api/v1",ee),te.get("/api/v1/auth/google",n.authenticate("google",{scope:["email","profile"]})),te.get("/api/v1/auth/google/callback",n.authenticate("google",{failureRedirect:"/failed"}),((e,t,s)=>{try{const{user:s,token:r}=e.user;t.redirect(`${N.frontBaseUrl}/auth/google/callback?user=${JSON.stringify(s)}&token=${r}`)}catch(e){s(e)}})),te.use(((e,t,s,r)=>{if(e instanceof f)return R.warn(`Validation error: ${JSON.stringify(q(e))}`,{metadata:{url:t.url,method:t.method,service:"server"}}),s.status(422).json(q(e));const{statusCode:a,message:o}=e,n={code:a||500,message:o};n.code>=500?R.error(`Internal server error: ${JSON.stringify(n)}`,{metadata:{url:t.url,method:t.method,body:JSON.stringify(t.body||{}),service:"server"}}):R.warn(`${n.code} error: ${JSON.stringify(n)}`,{metadata:{url:t.url,method:t.method,service:"server"}}),s.status(n.code).json(n)}));const se=a(te),re=new i(se,{cors:{origin:N.frontBaseUrl,methods:["GET","POST"],credentials:!0}});se.listen(N.expressPort,(()=>R.info(`server started on port ${N.expressPort} with env ${N.env}`,{metadata:{service:"server"}}))),function(e){e.on("connection",(t=>{new K(e,t)}))}(re);
