import e from"body-parser";import t from"compression";import s from"cors";import r from"express";import{createServer as a}from"http";import n from"morgan-body";import{Server as o}from"socket.io";import i from"winston";import"winston-mongodb";import d from"mongoose";import c from"passport";import"passport-google-oauth20";import{ExtractJwt as l,Strategy as u}from"passport-jwt";import m from"bcryptjs";import{StatusCodes as p}from"http-status-codes";import h,{DataTypes as w,Model as y,Op as I,ValidationError as g}from"sequelize";import f from"jsonwebtoken";import{v4 as v}from"uuid";import E from"sib-api-v3-sdk";var O={jwtSecret:process.env.JWT_SECRET,google:{clientId:process.env.GOOGLE_CLIENT_ID,clientSecret:process.env.GOOGLE_CLIENT_SECRET,callbackUrl:process.env.GOOGLE_CALLBACK_URL},frontBaseUrl:process.env.FRONT_BASE_URL||"http://localhost:8001",backBaseUrl:process.env.BACK_BASE_URL||"http://localhost:9000",mongodb:{dbname:process.env.MONGODB_DBNAME,host:process.env.MONGODB_HOST,port:process.env.MONGODB_PORT,login:process.env.MONGODB_LOGIN,password:process.env.MONGODB_PASSWORD,uri:process.env.MONGODB_URI},expressPort:process.env.PORT||9e3,env:process.env.NODE_ENV||"development",mailerKey:process.env.MAILER_KEY};d.set("strictQuery",!1),d.connect(O.mongodb.uri||"mongodb://localhost:27017/notes-project"),d.connection.on("connected",(()=>{console.log("Mongoose default connection open")})),d.connection.on("error",(e=>{console.log(`Mongoose default connection error: ${e}`)})),d.connection.on("disconnected",(()=>{console.log("Mongoose default connection disconnected")})),process.on("SIGINT",(()=>{d.connection.close((()=>{console.log("Mongoose default connection disconnected through app termination"),process.exit(0)}))}));const{transports:N}=i,R=i.createLogger({level:"info",format:i.format.json(),defaultMeta:{service:"user-service"},transports:[new N.MongoDB({db:d.connection,collection:"logs"})]});"production"!==process.env.NODE_ENV&&R.add(new i.transports.Console({format:i.format.simple()}));const S="development"===process.env.NODE_ENV?{newUrlParser:!0}:{dialectOptions:{ssl:{require:!0,rejectUnauthorized:!1}}},U=new h(process.env.POSTGRES_DATABASE_URL,S);U.authenticate().then((()=>{console.log("Postgres (with sequelize) default connection open.")})).catch((e=>{console.error(`Unable to connect to the database >> ${process.env.POSTGRES_DATABASE_URL}:`,e)}));class T extends y{}T.init({id:{type:w.UUID,defaultValue:w.UUIDV4,primaryKey:!0},text:{type:w.STRING,allowNull:!1},edited:{type:w.BOOLEAN,defaultValue:!1},deleted:{type:w.BOOLEAN,defaultValue:!1}},{sequelize:U,modelName:"message"});class D extends Error{constructor(e,t,s=!0,r=""){super(t),this.statusCode=e,this.isOperational=s,r?this.stack=r:Error.captureStackTrace(this,this.constructor)}}const b=Object.freeze({ROLE_ADMIN:"ROLE_ADMIN",ROLE_USER:"ROLE_USER"}),A=Object.freeze({PENDING:"PENDING",ACTIVE:"ACTIVE",BLOCKED:"BLOCKED",EXISTS:"EXISTS",UNKNOWN_USER:"UNKNOWN_USER",ADDED:"ADDED",ERROR_SAME_USER:"ERROR_SAME_USER"}),_=Object.freeze({CONFIRM_EMAIL:"CONFIRM_EMAIL",RESET_PASSWORD:"RESET_PASSWORD"});class k extends y{}k.init({id:{type:w.UUID,defaultValue:w.UUIDV4,primaryKey:!0},status:{type:w.STRING,validate:{isIn:{args:[Object.values(A)],msg:`Status must be one of: ${Object.values(A)}`}},allowNull:!1}},{sequelize:U,modelName:"friend"}),k.addHook("beforeCreate",((e,t)=>k.findOne({where:{[I.or]:[{senderId:e.senderId,receiverId:e.receiverId},{senderId:e.receiverId,receiverId:e.senderId}]}}).then((e=>{if(e)throw new D(p.UNPROCESSABLE_ENTITY,"friend already exists")}))));class M extends y{}M.init({id:{type:w.UUID,defaultValue:w.UUIDV4,primaryKey:!0},email:{type:w.STRING,allowNull:!1,unique:!0,validate:{isEmail:!0}},password:{type:w.STRING,allowNull:!0,validate:{len:[8,100]}},googleId:{type:w.STRING,allowNull:!0,unique:!0},role:{type:w.STRING,allowNull:!1,defaultValue:b.ROLE_USER},username:{type:w.STRING,allowNull:!1,unique:!0,defaultValue:""},avatar:{type:w.STRING,allowNull:!0,defaultValue:`https://avatars.dicebear.com/api/male/${100*Math.random()}.svg`},active:{type:w.BOOLEAN,allowNull:!1,defaultValue:!1}},{sequelize:U,modelName:"user"}),M.addHook("beforeCreate",(async e=>{e.password&&(e.password=await m.hash(e.password,await m.genSalt()))})),M.addHook("beforeUpdate",(async(e,{fields:t})=>{t.includes("password")&&(e.password=await m.hash(e.password,await m.genSalt()))}));class j extends y{}j.init({id:{type:w.UUID,defaultValue:w.UUIDV4,primaryKey:!0},title:{type:w.STRING}},{sequelize:U,modelName:"interest"});class L extends y{}L.init({id:{type:w.UUID,defaultValue:w.UUIDV4,primaryKey:!0},token:{type:w.STRING,allowNull:!1},type:{type:w.STRING,allowNull:!1,validate:{isIn:{args:[Object.values(_)],msg:`type must be one of: ${Object.values(_)}`}}}},{sequelize:U,modelName:"token"}),T.belongsTo(M,{as:"sender",foreignKey:"senderId"}),T.belongsTo(M,{as:"receiver",foreignKey:"receiverId"}),k.belongsTo(M,{as:"sender",foreignKey:"senderId"}),k.belongsTo(M,{as:"receiver",foreignKey:"receiverId"}),M.hasMany(T,{as:"invitations",foreignKey:"receiverId"}),M.belongsToMany(j,{through:"UserInterest"}),j.belongsToMany(M,{through:"UserInterest"}),M.hasMany(L),L.belongsTo(M);const G=async(e,t)=>{try{const s=await M.findByPk(e.id,{include:[{model:j,as:"interests"}]});if(!s)return t(null,!1);t(null,s)}catch(e){t(e,!1)}},B=e=>T.create(e),P=new Set,C=new Map;class V{constructor(e,t){this.socket=t,this.io=e,this.login(t.handshake.query.userId),this.io.sockets.emit("users.count",C.size),t.on("getMessages",(()=>this.getMessages())),t.on("message",(e=>this.handleMessage(e))),t.on("deleteUser",(e=>this.deleteUser(e))),t.on("connect_error",(e=>{console.log(`connect_error due to ${e.message}`)})),t.on("isTyping",(e=>{this.sendIsTyping(e)})),t.on("disconnect",(()=>{C.delete(this.socket.handshake.query.userId),e.sockets.emit("users.count",C.size)}))}login(e){C.set(e,this.socket)}async sendMessage(e){if(C.has(e.receiver.id))try{this.io.sockets.to(C.get(e.receiver.id).id).emit("message",e),this.io.sockets.to(C.get(e.sender.id).id).emit("message",e)}catch(e){R.error("socket IO error",{metadata:e})}await B({text:e.text,senderId:e.sender.id,receiverId:e.receiver.id})}async sendIsTyping(e){if(C.has(e.receiver.id))try{this.io.sockets.to(C.get(e.receiver.id).id).emit("isTyping",{id:v(),...e})}catch(e){R.error("socket IO error",{metadata:e})}}getMessages(){P.forEach((e=>this.sendMessage(e)))}handleMessage(e){const t={id:v(),text:e.text,receiver:{...e.receiver},sender:{...e.sender},createdAt:Date.now()};P.add(t),this.sendMessage(t),P.delete(t)}deleteMessage(e){this.io.sockets.emit("deleteMessage",e)}deleteUser(e){C.delete(e)}}const x=e=>e.errors.reduce(((e,t)=>(e[t.path]=t.message,e)),{});E.ApiClient.instance.authentications["api-key"].apiKey=O.mailerKey;const K=r.Router();K.post("/register",(async(e,t,s)=>{try{const s=await(async e=>{const{email:t,username:s,password:r,interests:a}=e;if(!a?.length)throw new D(p.UNPROCESSABLE_ENTITY,"At least one interest is required");const n=await M.create({email:t,username:s,password:r}),o=await j.findAll({where:{id:{[I.in]:a.map((e=>e.id))}}});return await n.addInterests(o),M.findByPk(n.id,{include:[{model:j,as:"interests"}]})})(e.body),r=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);await L.create({userId:s.id,token:r,type:_.CONFIRM_EMAIL}),await(async(e,t)=>{const s=new E.TransactionalEmailsApi,r={to:[{email:e}],templateId:2,params:{link:`${O.backBaseUrl}/api/v1/auth/validate?token=${t}`}};return s.sendTransacEmail(r)})(e.body.email,r),t.json({id:s.id})}catch(e){s(e)}})),K.post("/login",(async(e,t,s)=>{try{const{email:s,password:r}=e.body,a=await(async(e,t)=>{const s=await M.findOne({where:{email:e},include:[{model:j,as:"interests"}]});if(!s)throw new D(p.UNAUTHORIZED,"Incorrect credentials");if(!s.active)throw new D(p.UNAUTHORIZED,"User is not validated");if(s?.googleId)return!1;if(!await m.compare(t,s?.password))throw new D(p.UNAUTHORIZED,"Incorrect credentials");return s})(s,r),n=await(async e=>f.sign({id:e.id},O.jwtSecret,{expiresIn:"1y"}))(a);t.send({user:a,token:n})}catch(e){s(e)}})),K.get("/validate",(async(e,t,s)=>{try{const{token:s}=e.query,r=await L.findOne({where:{token:s,type:_.CONFIRM_EMAIL},include:[{model:M,as:"user"}]});await r.destroy(),await M.update({active:!0},{where:{email:r?.user?.email},returning:!0,individualHooks:!0}),t.redirect(301,O.frontBaseUrl)}catch(e){s(e)}})),K.post("/reset-password",(async(e,t,s)=>{try{const{email:s}=e.body,r=await M.findOne({where:{email:s}});if(!r)throw new D(p.NOT_FOUND,"Invalid email");const a=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);await L.create({userId:r.id,token:a,type:_.RESET_PASSWORD}),await(async(e,t)=>{const s=new E.TransactionalEmailsApi,r={to:[{email:e}],templateId:3,params:{link:`${O.frontBaseUrl}/reset-password?token=${t}`}};return s.sendTransacEmail(r)})(s,a),t.json({id:r.id})}catch(e){s(e)}}));function $(e=b.ROLE_USER){return async(e,t,s)=>new Promise(((r,a)=>{c.authenticate("jwt",{session:!1},((e,t,s,r)=>async(r,a,n)=>{if(r||n||!a)return s(new D(p.UNAUTHORIZED,"unauthorized"));e.user=a,t()})(e,r,a))(e,t,s)})).then((()=>s())).catch((e=>{s(e)}))}const q=r.Router();q.post("/reset-password",(async(e,t,s)=>{try{const{token:s,password:r}=e.body,a=await L.findOne({where:{token:s,type:_.RESET_PASSWORD},include:[{model:M,as:"user"}]});if(!a)throw new D(p.UNAUTHORIZED,"Invalid token");await a.destroy(),await M.update({password:r},{where:{email:a?.user?.email},returning:!0,individualHooks:!0}),t.json({message:"Password has been changed"})}catch(e){s(e)}})),q.get("/token",$(),(async(e,t,s)=>{try{t.json(e.user)}catch(e){s(e)}})),q.put("/profile",$(),(async(e,t,s)=>{try{const{username:s,interests:r}=e.body,a=await M.findOne({where:{id:e.user.id},include:[{model:j,as:"interests"}]}).then((async e=>{if(!e)throw new D(p.NOT_FOUND,"User not found");e.username=s;const t=await j.findAll({where:{id:{[I.in]:r.map((e=>e.id))}}});return await e.setInterests(t),e.save()})).then((e=>M.findByPk(e.id,{include:[{model:j,as:"interests"}]})));t.json(a)}catch(e){s(e)}})),q.put("/password",$(),(async(e,t,s)=>{try{const{oldPassword:s,newPassword:r}=e.body,a=await M.findOne({where:{id:e.user.id}});if(!a)throw new D(p.NOT_FOUND,"User not found");if(!await m.compare(s,a?.password))throw new D(p.UNAUTHORIZED,"Invalid old password");const n=await M.update({password:r},{where:{id:e.user.id},returning:!0,individualHooks:!0});t.json(n)}catch(e){s(e)}}));const z=r.Router();z.post("/",$(),(async(e,t,s)=>{const{receiverId:r}=e.body,{id:a}=e.user;await k.findOne({where:{[I.or]:[{senderId:a,receiverId:r},{senderId:r,receiverId:a}]}})||s(new D(p.UNAUTHORIZED,"You are not friends with this user")),s()}),(async(e,t,s)=>{try{const{text:s,receiverId:r}=e.body,a=await B({text:s,senderId:e.user.id,receiverId:r});t.json(a)}catch(e){s(e)}})),z.put("/:messageId",$(),(async(e,t,s)=>{const{id:r}=e.user,{messageId:a}=e.params;(await T.findByPk(a)).senderId!==r&&s(new D(p.UNAUTHORIZED,"Cant edit a message that is not yours")),s()}),(async(e,t,s)=>{try{const{messageId:s}=e.params,{body:r}=e,a=await((e,t)=>T.update(t,{where:{id:e},returning:!0}))(s,r);t.json(a)}catch(e){s(e)}})),z.get("/:senderId/:receiverId",$(),(async(e,t,s)=>{try{const{senderId:s,receiverId:r}=e.params,a=await((e,t)=>T.findAll({where:{[I.or]:[{senderId:e,receiverId:t},{senderId:t,receiverId:e}]},include:[{model:M,as:"sender",attributes:["email"]},{model:M,as:"receiver",attributes:["email"]}],order:[["createdAt","ASC"]]}))(s,r);t.json(a)}catch(e){s(e)}}));const H=r.Router();H.get("/:userId",$(),(async(e,t,s)=>{try{const{userId:s}=e.params,r=await(async(e,t=[A.ACTIVE,A.PENDING])=>k.findAll({where:{[I.or]:[{senderId:e},{receiverId:e}],status:{[I.or]:t}},include:[{model:M,as:"sender",attributes:["id","email","username","avatar"]},{model:M,as:"receiver",attributes:["id","email","username","avatar"]}]}))(s);t.json(r||[])}catch(e){s(e)}})),H.post("/add",$(),(async(e,t,s)=>{try{const{receiverNameOrEmail:s}=e.body,r=await(({senderId:e,receiverId:t})=>""===t||void 0===t?"null":M.findOne({where:{[I.or]:[{username:t},{email:t}]}}).then((t=>t?t.id===e?{status:"ERROR_SAME_USER"}:k.findOne({where:{[I.or]:[{senderId:e,receiverId:t.id},{senderId:t.id,receiverId:e}]}}).then((s=>{if(s)switch(s.status){case A.ACTIVE:return{status:A.EXISTS};case A.PENDING:return{status:A.PENDING}}return k.create({senderId:e,receiverId:t.id,status:A.PENDING}).then((()=>({status:A.ADDED})))})):{status:A.UNKNOWN_USER})).catch((e=>{console.log(e)})))({senderId:e.user.id,receiverId:s});t.json(r)}catch(e){s(e)}})),H.put("/:friendId",$(),(async(e,t,s)=>{try{const{friendId:s}=e.params,r=await(e=>k.update({status:A.ACTIVE},{where:{id:e},returning:!0}).then((e=>e[1][0])))(s);t.json(r)}catch(e){s(e)}})),H.delete("/:friendId",$(),(async(e,t,s)=>{try{const{friendId:s}=e.params,r=await k.destroy({where:{id:s}});t.json(r)}catch(e){s(e)}})),H.get("/:friendId/chat",$(),(async(e,t,s)=>{try{const{friendId:s}=e.params,n=await(r=s,a=e.user.id,T.findAll({where:{[I.or]:[{senderId:r,receiverId:a},{senderId:a,receiverId:r}]},include:[{model:M,as:"sender",attributes:["id","email","username","avatar"]},{model:M,as:"receiver",attributes:["id","email","username","avatar"]}]}).then((async e=>({friend:await M.findOne({where:{id:r},attributes:["id","email","username","avatar"]}),messages:e}))).catch((e=>{console.log(e)})));t.json(n||{})}catch(e){s(e)}var r,a}));const F=r.Router();F.get("/",(async(e,t,s)=>{try{const e=await j.findAll({});t.json(e)}catch(e){s(e)}}));const W=new d.Schema({level:{type:String,required:!0},message:{type:String,required:!0},timestamp:{type:Date,default:Date.now},meta:{type:Object,required:!1}},{timestamps:!0});W.index({message:"text"});const Z=d.model("Log",W),J=r.Router();J.post("/",$(),(async(e,t,s)=>{try{const{level:s,message:r,meta:a}=e.body;switch(s){case"error":R.error(r,{metadata:a});break;case"warn":R.warn(r,{metadata:a});break;case"info":R.info(r,{metadata:a});break;default:throw new Error("Level is not valid")}t.json({message:r,meta:a})}catch(e){s(e)}})),J.post("/search",$("ROLE_ADMIN"),(async(e,t,s)=>{try{const{startDate:s,endDate:r,page:a,limit:n,textSearch:o,severity:i,application:d}=e.body,c={...o&&{$text:{$search:o}},...i&&{level:i},...d&&{"meta.service":d},...s&&r&&{timestamp:{$gte:new Date(s),$lte:new Date(r)}}},l=await Z.find(c).skip(a*n).limit(n).sort({timestamp:-1}),u=await Z.countDocuments(c);t.json({logs:l,total:u})}catch(e){s(e)}}));const Y=r.Router();[{path:"auth",routes:K},{path:"users",routes:q},{path:"messages",routes:z},{path:"friends",routes:H},{path:"interests",routes:F},{path:"logs",routes:J}].forEach((e=>{Y.use(`/${e.path}`,e.routes)}));const X=r();X.use(s({origin:"*"})),X.use(e.json()),n(X,{logResponseBody:!0}),X.use(r.json()),function(e){e.use(c.initialize()),c.serializeUser(((e,t)=>{t(null,e)})),c.deserializeUser(((e,t)=>{t(null,e)}));const t={jwtFromRequest:l.fromAuthHeaderAsBearerToken(),secretOrKey:O.jwtSecret};c.use(new u(t,G))}(X),X.use(t({level:9})),X.get("/ping",((e,t)=>{t.send("pong")})),X.use("/api/v1",Y),X.use(((e,t,s,r)=>{if(e instanceof g)return R.warn(`Validation error: ${JSON.stringify(x(e))}`,{metadata:{url:t.url,method:t.method,service:"server"}}),s.status(422).json(x(e));const{statusCode:a,message:n}=e,o={code:a||500,message:n};o.code>=500?R.error(`Internal server error: ${JSON.stringify(o)}`,{metadata:{url:t.url,method:t.method,body:JSON.stringify(t.body||{}),service:"server"}}):R.warn(`${o.code} error: ${JSON.stringify(o)}`,{metadata:{url:t.url,method:t.method,service:"server"}}),s.status(o.code).json(o)}));const Q=a(X),ee=new o(Q,{cors:{origin:O.frontBaseUrl,methods:["GET","POST"],credentials:!0}});Q.listen(O.expressPort,(()=>R.info(`server started on port ${O.expressPort} with env ${O.env}`,{metadata:{service:"server"}}))),function(e){e.on("connection",(t=>{new V(e,t)}))}(ee);
