import e from"body-parser";import t from"compression";import s from"cors";import r from"express";import{createServer as a}from"http";import n from"morgan-body";import{Server as o}from"socket.io";import i from"winston";import"winston-mongodb";import d from"mongoose";import c from"passport";import"passport-google-oauth20";import{ExtractJwt as l,Strategy as u}from"passport-jwt";import m from"bcryptjs";import{StatusCodes as p}from"http-status-codes";import h,{DataTypes as w,Model as y,Op as I,ValidationError as g}from"sequelize";import f from"jsonwebtoken";import{v4 as v}from"uuid";import E from"sib-api-v3-sdk";var O={jwtSecret:process.env.JWT_SECRET,google:{clientId:process.env.GOOGLE_CLIENT_ID,clientSecret:process.env.GOOGLE_CLIENT_SECRET,callbackUrl:process.env.GOOGLE_CALLBACK_URL},frontBaseUrl:process.env.FRONT_BASE_URL||"http://localhost:8001",backBaseUrl:process.env.BACK_BASE_URL||"http://localhost:9000",mongodb:{dbname:process.env.MONGODB_DBNAME,host:process.env.MONGODB_HOST,port:process.env.MONGODB_PORT,login:process.env.MONGODB_LOGIN,password:process.env.MONGODB_PASSWORD,uri:process.env.MONGODB_URI},expressPort:process.env.PORT||9e3,env:process.env.NODE_ENV||"development",mailerKey:process.env.MAILER_KEY};d.set("strictQuery",!1),d.connect(O.mongodb.uri||"mongodb://localhost:27017/notes-project"),d.connection.on("connected",(()=>{console.log("Mongoose default connection open")})),d.connection.on("error",(e=>{console.log(`Mongoose default connection error: ${e}`)})),d.connection.on("disconnected",(()=>{console.log("Mongoose default connection disconnected")})),process.on("SIGINT",(()=>{d.connection.close((()=>{console.log("Mongoose default connection disconnected through app termination"),process.exit(0)}))}));const{transports:N}=i,R=i.createLogger({level:"info",format:i.format.json(),defaultMeta:{service:"user-service"},transports:[new N.MongoDB({db:d.connection,collection:"logs"})]});"production"!==process.env.NODE_ENV&&R.add(new i.transports.Console({format:i.format.simple()}));const S=new h(process.env.POSTGRES_DATABASE_URL,{newUrlParser:!0});S.authenticate().then((()=>{console.log("Postgres (with sequelize) default connection open.")})).catch((e=>{console.error(`Unable to connect to the database >> ${process.env.POSTGRES_DATABASE_URL}:`,e)}));class U extends y{}U.init({id:{type:w.UUID,defaultValue:w.UUIDV4,primaryKey:!0},text:{type:w.STRING,allowNull:!1},edited:{type:w.BOOLEAN,defaultValue:!1},deleted:{type:w.BOOLEAN,defaultValue:!1}},{sequelize:S,modelName:"message"});class T extends Error{constructor(e,t,s=!0,r=""){super(t),this.statusCode=e,this.isOperational=s,r?this.stack=r:Error.captureStackTrace(this,this.constructor)}}const b=Object.freeze({ROLE_ADMIN:"ROLE_ADMIN",ROLE_USER:"ROLE_USER"}),D=Object.freeze({PENDING:"PENDING",ACTIVE:"ACTIVE",BLOCKED:"BLOCKED",EXISTS:"EXISTS",UNKNOWN_USER:"UNKNOWN_USER",ADDED:"ADDED",ERROR_SAME_USER:"ERROR_SAME_USER"}),A=Object.freeze({CONFIRM_EMAIL:"CONFIRM_EMAIL",RESET_PASSWORD:"RESET_PASSWORD"});class _ extends y{}_.init({id:{type:w.UUID,defaultValue:w.UUIDV4,primaryKey:!0},status:{type:w.STRING,validate:{isIn:{args:[Object.values(D)],msg:`Status must be one of: ${Object.values(D)}`}},allowNull:!1}},{sequelize:S,modelName:"friend"}),_.addHook("beforeCreate",((e,t)=>_.findOne({where:{[I.or]:[{senderId:e.senderId,receiverId:e.receiverId},{senderId:e.receiverId,receiverId:e.senderId}]}}).then((e=>{if(e)throw new T(p.UNPROCESSABLE_ENTITY,"friend already exists")}))));class k extends y{}k.init({id:{type:w.UUID,defaultValue:w.UUIDV4,primaryKey:!0},email:{type:w.STRING,allowNull:!1,unique:!0,validate:{isEmail:!0}},password:{type:w.STRING,allowNull:!0,validate:{len:[8,100]}},googleId:{type:w.STRING,allowNull:!0,unique:!0},role:{type:w.STRING,allowNull:!1,defaultValue:b.ROLE_USER},username:{type:w.STRING,allowNull:!1,unique:!0,defaultValue:""},avatar:{type:w.STRING,allowNull:!0,defaultValue:`https://avatars.dicebear.com/api/male/${100*Math.random()}.svg`},active:{type:w.BOOLEAN,allowNull:!1,defaultValue:!1}},{sequelize:S,modelName:"user"}),k.addHook("beforeCreate",(async e=>{e.password&&(e.password=await m.hash(e.password,await m.genSalt()))})),k.addHook("beforeUpdate",(async(e,{fields:t})=>{t.includes("password")&&(e.password=await m.hash(e.password,await m.genSalt()))}));class M extends y{}M.init({id:{type:w.UUID,defaultValue:w.UUIDV4,primaryKey:!0},title:{type:w.STRING}},{sequelize:S,modelName:"interest"});class j extends y{}j.init({id:{type:w.UUID,defaultValue:w.UUIDV4,primaryKey:!0},token:{type:w.STRING,allowNull:!1},type:{type:w.STRING,allowNull:!1,validate:{isIn:{args:[Object.values(A)],msg:`type must be one of: ${Object.values(A)}`}}}},{sequelize:S,modelName:"token"}),U.belongsTo(k,{as:"sender",foreignKey:"senderId"}),U.belongsTo(k,{as:"receiver",foreignKey:"receiverId"}),_.belongsTo(k,{as:"sender",foreignKey:"senderId"}),_.belongsTo(k,{as:"receiver",foreignKey:"receiverId"}),k.hasMany(U,{as:"invitations",foreignKey:"receiverId"}),k.belongsToMany(M,{through:"UserInterest"}),M.belongsToMany(k,{through:"UserInterest"}),k.hasMany(j),j.belongsTo(k);const L=async(e,t)=>{try{const s=await k.findByPk(e.id,{include:[{model:M,as:"interests"}]});if(!s)return t(null,!1);t(null,s)}catch(e){t(e,!1)}},G=e=>U.create(e),B=new Set,P=new Map;class C{constructor(e,t){this.socket=t,this.io=e,this.login(t.handshake.query.userId),this.io.sockets.emit("users.count",P.size),t.on("getMessages",(()=>this.getMessages())),t.on("message",(e=>this.handleMessage(e))),t.on("deleteUser",(e=>this.deleteUser(e))),t.on("connect_error",(e=>{console.log(`connect_error due to ${e.message}`)})),t.on("isTyping",(e=>{this.sendIsTyping(e)})),t.on("disconnect",(()=>{P.delete(this.socket.handshake.query.userId),e.sockets.emit("users.count",P.size)}))}login(e){P.set(e,this.socket)}async sendMessage(e){P.has(e.receiver.id)&&(this.io.sockets.to(P.get(e.receiver.id).id).emit("message",e),this.io.sockets.to(P.get(e.sender.id).id).emit("message",e)),await G({text:e.text,senderId:e.sender.id,receiverId:e.receiver.id})}async sendIsTyping(e){P.has(e.receiver.id)&&this.io.sockets.to(P.get(e.receiver.id).id).emit("isTyping",{id:v(),...e})}getMessages(){B.forEach((e=>this.sendMessage(e)))}handleMessage(e){const t={id:v(),text:e.text,receiver:{...e.receiver},sender:{...e.sender},createdAt:Date.now()};B.add(t),this.sendMessage(t),B.delete(t)}deleteMessage(e){this.io.sockets.emit("deleteMessage",e)}deleteUser(e){P.delete(e)}}const x=e=>e.errors.reduce(((e,t)=>(e[t.path]=t.message,e)),{});E.ApiClient.instance.authentications["api-key"].apiKey=O.mailerKey;const V=r.Router();V.post("/register",(async(e,t,s)=>{try{const s=await(async e=>{const{email:t,username:s,password:r,interests:a}=e;if(!a?.length)throw new T(p.UNPROCESSABLE_ENTITY,"At least one interest is required");const n=await k.create({email:t,username:s,password:r}),o=await M.findAll({where:{id:{[I.in]:a.map((e=>e.id))}}});return await n.addInterests(o),k.findByPk(n.id,{include:[{model:M,as:"interests"}]})})(e.body),r=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);await j.create({userId:s.id,token:r,type:A.CONFIRM_EMAIL}),await(async(e,t)=>{const s=new E.TransactionalEmailsApi,r={to:[{email:e}],templateId:2,params:{link:`${O.backBaseUrl}/api/v1/auth/validate?token=${t}`}};return s.sendTransacEmail(r)})(e.body.email,r),t.json({id:s.id})}catch(e){s(e)}})),V.post("/login",(async(e,t,s)=>{try{const{email:s,password:r}=e.body,a=await(async(e,t)=>{const s=await k.findOne({where:{email:e},include:[{model:M,as:"interests"}]});if(!s)throw new T(p.UNAUTHORIZED,"Incorrect credentials");if(!s.active)throw new T(p.UNAUTHORIZED,"User is not validated");if(s?.googleId)return!1;if(!await m.compare(t,s?.password))throw new T(p.UNAUTHORIZED,"Incorrect credentials");return s})(s,r),n=await(async e=>f.sign({id:e.id},O.jwtSecret,{expiresIn:"1y"}))(a);t.send({user:a,token:n})}catch(e){s(e)}})),V.get("/validate",(async(e,t,s)=>{try{const{token:s}=e.query,r=await j.findOne({where:{token:s,type:A.CONFIRM_EMAIL},include:[{model:k,as:"user"}]});await r.destroy(),await k.update({active:!0},{where:{email:r?.user?.email},returning:!0,individualHooks:!0}),t.redirect(301,O.frontBaseUrl)}catch(e){s(e)}})),V.post("/reset-password",(async(e,t,s)=>{try{const{email:s}=e.body,r=await k.findOne({where:{email:s}});if(!r)throw new T(p.NOT_FOUND,"Invalid email");const a=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);await j.create({userId:r.id,token:a,type:A.RESET_PASSWORD}),await(async(e,t)=>{const s=new E.TransactionalEmailsApi,r={to:[{email:e}],templateId:3,params:{link:`${O.frontBaseUrl}/reset-password?token=${t}`}};return s.sendTransacEmail(r)})(s,a),t.json({id:r.id})}catch(e){s(e)}}));function K(e=b.ROLE_USER){return async(e,t,s)=>new Promise(((r,a)=>{c.authenticate("jwt",{session:!1},((e,t,s,r)=>async(r,a,n)=>{if(r||n||!a)return s(new T(p.UNAUTHORIZED,"unauthorized"));e.user=a,t()})(e,r,a))(e,t,s)})).then((()=>s())).catch((e=>{s(e)}))}const $=r.Router();$.post("/reset-password",(async(e,t,s)=>{try{const{token:s,password:r}=e.body,a=await j.findOne({where:{token:s,type:A.RESET_PASSWORD},include:[{model:k,as:"user"}]});if(!a)throw new T(p.UNAUTHORIZED,"Invalid token");await a.destroy(),await k.update({password:r},{where:{email:a?.user?.email},returning:!0,individualHooks:!0}),t.json({message:"Password has been changed"})}catch(e){s(e)}})),$.get("/token",K(),(async(e,t,s)=>{try{t.json(e.user)}catch(e){s(e)}})),$.put("/profile",K(),(async(e,t,s)=>{try{const{username:s,interests:r}=e.body,a=await k.findOne({where:{id:e.user.id},include:[{model:M,as:"interests"}]}).then((async e=>{if(!e)throw new T(p.NOT_FOUND,"User not found");e.username=s;const t=await M.findAll({where:{id:{[I.in]:r.map((e=>e.id))}}});return await e.setInterests(t),e.save()})).then((e=>k.findByPk(e.id,{include:[{model:M,as:"interests"}]})));t.json(a)}catch(e){s(e)}})),$.put("/password",K(),(async(e,t,s)=>{try{const{oldPassword:s,newPassword:r}=e.body,a=await k.findOne({where:{id:e.user.id}});if(!a)throw new T(p.NOT_FOUND,"User not found");if(!await m.compare(s,a?.password))throw new T(p.UNAUTHORIZED,"Invalid old password");const n=await k.update({password:r},{where:{id:e.user.id},returning:!0,individualHooks:!0});t.json(n)}catch(e){s(e)}}));const q=r.Router();q.post("/",K(),(async(e,t,s)=>{const{receiverId:r}=e.body,{id:a}=e.user;await _.findOne({where:{[I.or]:[{senderId:a,receiverId:r},{senderId:r,receiverId:a}]}})||s(new T(p.UNAUTHORIZED,"You are not friends with this user")),s()}),(async(e,t,s)=>{try{const{text:s,receiverId:r}=e.body,a=await G({text:s,senderId:e.user.id,receiverId:r});t.json(a)}catch(e){s(e)}})),q.put("/:messageId",K(),(async(e,t,s)=>{const{id:r}=e.user,{messageId:a}=e.params;(await U.findByPk(a)).senderId!==r&&s(new T(p.UNAUTHORIZED,"Cant edit a message that is not yours")),s()}),(async(e,t,s)=>{try{const{messageId:s}=e.params,{body:r}=e,a=await((e,t)=>U.update(t,{where:{id:e},returning:!0}))(s,r);t.json(a)}catch(e){s(e)}})),q.get("/:senderId/:receiverId",K(),(async(e,t,s)=>{try{const{senderId:s,receiverId:r}=e.params,a=await((e,t)=>U.findAll({where:{[I.or]:[{senderId:e,receiverId:t},{senderId:t,receiverId:e}]},include:[{model:k,as:"sender",attributes:["email"]},{model:k,as:"receiver",attributes:["email"]}],order:[["createdAt","ASC"]]}))(s,r);t.json(a)}catch(e){s(e)}}));const z=r.Router();z.get("/:userId",K(),(async(e,t,s)=>{try{const{userId:s}=e.params,r=await(async(e,t=[D.ACTIVE,D.PENDING])=>_.findAll({where:{[I.or]:[{senderId:e},{receiverId:e}],status:{[I.or]:t}},include:[{model:k,as:"sender",attributes:["id","email","username","avatar"]},{model:k,as:"receiver",attributes:["id","email","username","avatar"]}]}))(s);t.json(r||[])}catch(e){s(e)}})),z.post("/add",K(),(async(e,t,s)=>{try{const{receiverNameOrEmail:s}=e.body,r=await(({senderId:e,receiverId:t})=>""===t||void 0===t?"null":k.findOne({where:{[I.or]:[{username:t},{email:t}]}}).then((t=>t?t.id===e?{status:"ERROR_SAME_USER"}:_.findOne({where:{[I.or]:[{senderId:e,receiverId:t.id},{senderId:t.id,receiverId:e}]}}).then((s=>{if(s)switch(s.status){case D.ACTIVE:return{status:D.EXISTS};case D.PENDING:return{status:D.PENDING}}return _.create({senderId:e,receiverId:t.id,status:D.PENDING}).then((()=>({status:D.ADDED})))})):{status:D.UNKNOWN_USER})).catch((e=>{console.log(e)})))({senderId:e.user.id,receiverId:s});t.json(r)}catch(e){s(e)}})),z.put("/:friendId",K(),(async(e,t,s)=>{try{const{friendId:s}=e.params,r=await(e=>_.update({status:D.ACTIVE},{where:{id:e},returning:!0}).then((e=>e[1][0])))(s);t.json(r)}catch(e){s(e)}})),z.delete("/:friendId",K(),(async(e,t,s)=>{try{const{friendId:s}=e.params,r=await _.destroy({where:{id:s}});t.json(r)}catch(e){s(e)}})),z.get("/:friendId/chat",K(),(async(e,t,s)=>{try{const{friendId:s}=e.params,n=await(r=s,a=e.user.id,U.findAll({where:{[I.or]:[{senderId:r,receiverId:a},{senderId:a,receiverId:r}]},include:[{model:k,as:"sender",attributes:["id","email","username","avatar"]},{model:k,as:"receiver",attributes:["id","email","username","avatar"]}]}).then((async e=>({friend:await k.findOne({where:{id:r},attributes:["id","email","username","avatar"]}),messages:e}))).catch((e=>{console.log(e)})));t.json(n||{})}catch(e){s(e)}var r,a}));const H=r.Router();H.get("/",(async(e,t,s)=>{try{const e=await M.findAll({});t.json(e)}catch(e){s(e)}}));const F=new d.Schema({level:{type:String,required:!0},message:{type:String,required:!0},timestamp:{type:Date,default:Date.now},meta:{type:Object,required:!1}},{timestamps:!0});F.index({message:"text"});const W=d.model("Log",F),Z=r.Router();Z.post("/",K(),(async(e,t,s)=>{try{const{level:s,message:r,meta:a}=e.body;switch(s){case"error":R.error(r,{metadata:a});break;case"warn":R.warn(r,{metadata:a});break;case"info":R.info(r,{metadata:a});break;default:throw new Error("Level is not valid")}t.json({message:r,meta:a})}catch(e){s(e)}})),Z.post("/search",K("ROLE_ADMIN"),(async(e,t,s)=>{try{const{startDate:s,endDate:r,page:a,limit:n,textSearch:o,severity:i,application:d}=e.body,c={...o&&{$text:{$search:o}},...i&&{level:i},...d&&{"meta.service":d},...s&&r&&{timestamp:{$gte:new Date(s),$lte:new Date(r)}}},l=await W.find(c).skip(a*n).limit(n).sort({timestamp:-1}),u=await W.countDocuments(c);t.json({logs:l,total:u})}catch(e){s(e)}}));const J=r.Router();[{path:"auth",routes:V},{path:"users",routes:$},{path:"messages",routes:q},{path:"friends",routes:z},{path:"interests",routes:H},{path:"logs",routes:Z}].forEach((e=>{J.use(`/${e.path}`,e.routes)}));const Y=r();Y.use(s({origin:"*"})),Y.use(e.json()),n(Y,{logResponseBody:!0}),Y.use(r.json()),function(e){e.use(c.initialize()),c.serializeUser(((e,t)=>{t(null,e)})),c.deserializeUser(((e,t)=>{t(null,e)}));const t={jwtFromRequest:l.fromAuthHeaderAsBearerToken(),secretOrKey:O.jwtSecret};c.use(new u(t,L))}(Y),Y.use(t({level:9})),Y.use("/api/v1",J),Y.use(((e,t,s,r)=>{if(e instanceof g)return R.warn(`Validation error: ${JSON.stringify(x(e))}`,{metadata:{url:t.url,method:t.method,service:"server"}}),s.status(422).json(x(e));const{statusCode:a,message:n}=e,o={code:a||500,message:n};o.code>=500?R.error(`Internal server error: ${JSON.stringify(o)}`,{metadata:{url:t.url,method:t.method,body:JSON.stringify(t.body||{}),service:"server"}}):R.warn(`${o.code} error: ${JSON.stringify(o)}`,{metadata:{url:t.url,method:t.method,service:"server"}}),s.status(o.code).json(o)}));const X=a(Y),Q=new o(X,{cors:{origin:O.frontBaseUrl,methods:["GET","POST"],credentials:!0}});X.listen(O.expressPort,(()=>R.info(`server started on port ${O.expressPort} with env ${O.env}`,{metadata:{service:"server"}}))),function(e){e.on("connection",(t=>{new C(e,t)}))}(Q);
